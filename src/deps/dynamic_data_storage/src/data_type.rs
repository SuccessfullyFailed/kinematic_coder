use std::error::Error;

pub trait GeneralDataType:Sized {

	/// Validate the value can be built from this byte count, then move on to from_bytes_inner. Will result in an error of value of the implemented type.
	fn from_bytes(bytes:&[u8]) -> Result<Self, Box<dyn Error>> {

		// Check byte size.
		let target_byte_size:usize = Self::byte_size();
		if bytes.len() != target_byte_size {
			return Err(format!("DRAWABLE DATA SETTING TYPE ERROR: Invalid byte size. expected {} bytes, got {}.", target_byte_size, bytes.len()).into());
		}

		// Continue on to inner function.
		Self::from_bytes_inner(bytes)
	}

	/// Create a value of the implemented type from these bytes.
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>>;

	/// Create a value of the implemented type from these bytes while removing the bytes required from the bytes list. Useful for parsing more advances structs.
	fn from_bytes_consume(bytes:&mut Vec<u8>) -> Result<Self, Box<dyn Error>> { Self::from_bytes(&bytes.drain(0..Self::byte_size()).collect::<Vec<u8>>()) }

	/// Create a list of bytes from the value.
	fn to_bytes(&self) -> Vec<u8>;

	/// Get the byte size of this type.
	fn byte_size() -> usize;
}

impl GeneralDataType for String {
	fn from_bytes(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Self::from_bytes_inner(bytes) }
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> {
		let end:usize = bytes.iter().enumerate().find(|(_, character)| *character == &0).map(|(end, _)| end).unwrap_or(bytes.len());
		Ok(String::from_utf8_lossy(&bytes[..end]).to_string())
	}
	fn from_bytes_consume(bytes:&mut Vec<u8>) -> Result<Self, Box<dyn Error>> {
		let mut end:usize = bytes.len();
		if let Some(null_terminator) = bytes.iter().enumerate().find(|(_, character)| *character == &0).map(|(end, _)| end) {
			end = null_terminator;
			bytes.remove(null_terminator);
		}
		Ok(String::from_utf8_lossy(&bytes.drain(..end).collect::<Vec<u8>>()).to_string())
	}
	fn byte_size() -> usize { 0 }
	fn to_bytes(&self) -> Vec<u8> { [self.chars().map(|character| character as u8).collect::<Vec<u8>>(), vec![0]].iter().flatten().copied().collect::<Vec<u8>>() }
}
impl GeneralDataType for Vec<u8> {
	fn from_bytes(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Self::from_bytes_inner(bytes) }
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(bytes.to_vec()) }
	fn from_bytes_consume(bytes:&mut Vec<u8>) -> Result<Self, Box<dyn Error>> { Ok(std::mem::take(bytes)) }
	fn byte_size() -> usize { 0 }
	fn to_bytes(&self) -> Vec<u8> { self[..].to_vec() }
}


/* AUTOGENERATED */



/* UNSIGNED INT METHODS */

impl GeneralDataType for u8 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(u8::from_le_bytes([bytes[0]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 1 }
}
impl GeneralDataType for u16 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(u16::from_le_bytes([bytes[0], bytes[1]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 2 }
}
impl GeneralDataType for u32 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 4 }
}
impl GeneralDataType for u64 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(u64::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 8 }
}
impl GeneralDataType for u128 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(u128::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7], bytes[8], bytes[9], bytes[10], bytes[11], bytes[12], bytes[13], bytes[14], bytes[15]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 16 }
}



/* SIGNED INT METHODS */

impl GeneralDataType for i8 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(i8::from_le_bytes([bytes[0]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 1 }
}
impl GeneralDataType for i16 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(i16::from_le_bytes([bytes[0], bytes[1]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 2 }
}
impl GeneralDataType for i32 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(i32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 4 }
}
impl GeneralDataType for i64 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(i64::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 8 }
}
impl GeneralDataType for i128 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(i128::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7], bytes[8], bytes[9], bytes[10], bytes[11], bytes[12], bytes[13], bytes[14], bytes[15]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 16 }
}



/* FLOATING POINT NUMBER METHODS */

impl GeneralDataType for f32 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(f32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 4 }
}
impl GeneralDataType for f64 {
	fn from_bytes_inner(bytes:&[u8]) -> Result<Self, Box<dyn Error>> { Ok(f64::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]])) }
	fn to_bytes(&self) -> Vec<u8> { self.to_le_bytes().to_vec() }
	fn byte_size() -> usize { 8 }
}


